import { db } from "../lib/db";
import { Template } from "../types/template";
import { ResponseFormat } from "../types/responseFormat";

export interface AIServiceOptions {
  model?: string;
  temperature?: number;
  maxTokens?: number;
  stopSequences?: string[];
}

export interface AIResponse {
  content: string | any;
  rawContent?: string;
  formatted: boolean;
  formatId?: number;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
}

export class AIService {
  /**
   * Process a user query using a template and optional response format
   */
  static async processQuery(
    query: string,
    templateId: number,
    variables: Record<string, any> = {},
    options: AIServiceOptions = {},
  ): Promise<AIResponse> {
    try {
      // Get the template
      const template = await db("templates").where("id", templateId).first();

      if (!template) {
        throw new Error(`Template with ID ${templateId} not found`);
      }

      // Increment template usage count
      await db("templates")
        .where("id", templateId)
        .update({
          usage_count: db.raw("usage_count + 1"),
          updated_at: new Date(),
        });

      // Process the template with variables
      const processedPrompt = this.processTemplate(template.content, {
        user_query: query,
        ...variables,
      });

      // Call AI model (mock implementation)
      const rawResponse = await this.callAIModel(processedPrompt, options);

      // Check if a response format should be applied
      if (template.response_format_id) {
        // Get the response format
        const format = await db("response_formats")
          .where("id", template.response_format_id)
          .first();

        if (format) {
          // Increment format usage count
          await db("response_formats")
            .where("id", template.response_format_id)
            .update({
              usage_count: db.raw("usage_count + 1"),
              updated_at: new Date(),
            });

          // Apply the format to the response
          const formattedResponse = await this.applyResponseFormat(
            rawResponse,
            JSON.parse(format.structure),
          );

          return {
            content: formattedResponse,
            rawContent: rawResponse,
            formatted: true,
            formatId: template.response_format_id,
            usage: {
              promptTokens: processedPrompt.length / 4,
              completionTokens: rawResponse.length / 4,
              totalTokens: (processedPrompt.length + rawResponse.length) / 4,
            },
          };
        }
      }

      // Return raw response if no format is applied
      return {
        content: rawResponse,
        formatted: false,
        usage: {
          promptTokens: processedPrompt.length / 4,
          completionTokens: rawResponse.length / 4,
          totalTokens: (processedPrompt.length + rawResponse.length) / 4,
        },
      };
    } catch (error) {
      console.error("Error processing query:", error);
      throw error;
    }
  }

  /**
   * Process a template by replacing variables
   */
  private static processTemplate(
    template: string,
    variables: Record<string, any>,
  ): string {
    let processedTemplate = template;

    // Replace all variables in the template
    Object.entries(variables).forEach(([key, value]) => {
      const regex = new RegExp(`{{\\s*${key}\\s*}}`, "g");
      processedTemplate = processedTemplate.replace(regex, String(value));
    });

    return processedTemplate;
  }

  /**
   * Call AI model with prompt (mock implementation)
   */
  private static async callAIModel(
    prompt: string,
    options: AIServiceOptions,
  ): Promise<string> {
    // This is a mock implementation
    // In a real implementation, this would call an actual AI model API

    // Simulate API call delay
    await new Promise((resolve) => setTimeout(resolve, 500));

    // Generate a mock response based on the prompt
    const firstSentence = prompt.split(".")[0];
    return `This is a simulated AI response to your query about ${firstSentence}. In a real implementation, this would be generated by an actual AI model like OpenAI's GPT or Google's Gemini. The response would be much more detailed and relevant to your specific query.\n\nHere are some key points that might be included:\n\n1. Detailed explanation of the topic\n2. Examples and use cases\n3. Best practices and recommendations\n4. Common pitfalls to avoid\n\nFor more information, you might want to check the documentation or ask a more specific question.`;
  }

  /**
   * Apply a response format to raw content
   */
  private static async applyResponseFormat(
    rawContent: string,
    formatStructure: any,
  ): Promise<any> {
    // This is a simplified implementation
    // In a real implementation, this would use more sophisticated parsing
    // and potentially call an AI model to structure the content

    // Create a copy of the format structure
    const formattedResponse = JSON.parse(JSON.stringify(formatStructure));

    // Extract potential sections from the raw content
    const paragraphs = rawContent.split("\n\n").filter((p) => p.trim());
    const sentences = rawContent.split(".").filter((s) => s.trim());
    const listItems = rawContent.match(/\d+\.\s+[^\n]+/g) || [];

    // Fill in the structure with content
    if (formattedResponse.title && !formattedResponse.title.length) {
      formattedResponse.title = sentences[0] || "Response";
    }

    if (formattedResponse.intro && !formattedResponse.intro.length) {
      formattedResponse.intro = paragraphs[0] || "";
    }

    // Fill in content blocks
    if (
      formattedResponse.content_blocks &&
      formattedResponse.content_blocks.length > 0
    ) {
      formattedResponse.content_blocks = formattedResponse.content_blocks.map(
        (block: any, index: number) => {
          if (
            block.type === "text" &&
            (!block.content || block.content === "")
          ) {
            return {
              ...block,
              content: paragraphs[index + 1] || paragraphs[0] || rawContent,
            };
          }
          if (
            block.type === "list" &&
            (!block.content || block.content.length === 0)
          ) {
            return {
              ...block,
              content:
                listItems.map((item) => item.replace(/^\d+\.\s+/, "")) ||
                sentences.slice(0, 3).map((s) => s.trim()),
            };
          }
          return block;
        },
      );
    }

    // If no content blocks, create one with the raw content
    if (
      !formattedResponse.content_blocks ||
      formattedResponse.content_blocks.length === 0
    ) {
      formattedResponse.content_blocks = [
        {
          type: "text",
          content: rawContent,
        },
      ];
    }

    return formattedResponse;
  }
}
